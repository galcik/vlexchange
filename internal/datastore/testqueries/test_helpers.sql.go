// Code generated by sqlc. DO NOT EDIT.
// source: test_helpers.sql

package testqueries

import (
	"context"
	"database/sql"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO account (username, token, usd_amount, btc_amount)
VALUES ($1, $2, $3, $4)
RETURNING id, username, token, usd_amount, btc_amount
`

type CreateAccountParams struct {
	Username  string
	Token     string
	UsdAmount int64
	BtcAmount int64
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount,
		arg.Username,
		arg.Token,
		arg.UsdAmount,
		arg.BtcAmount,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Token,
		&i.UsdAmount,
		&i.BtcAmount,
	)
	return i, err
}

const createStandingOrder = `-- name: CreateStandingOrder :one
INSERT INTO standing_order (account_id, type, state, quantity, filled_quantity, filled_price, limit_price,
                            reserved_btc_amount, reserved_usd_amount,
                            webhook_url)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, account_id, type, state, quantity, filled_quantity, filled_price, limit_price, reserved_usd_amount, reserved_btc_amount, webhook_url
`

type CreateStandingOrderParams struct {
	AccountID         int32
	Type              OrderType
	State             OrderState
	Quantity          int64
	FilledQuantity    int64
	FilledPrice       int64
	LimitPrice        int64
	ReservedBtcAmount int64
	ReservedUsdAmount int64
	WebhookUrl        sql.NullString
}

func (q *Queries) CreateStandingOrder(ctx context.Context, arg CreateStandingOrderParams) (StandingOrder, error) {
	row := q.db.QueryRowContext(ctx, createStandingOrder,
		arg.AccountID,
		arg.Type,
		arg.State,
		arg.Quantity,
		arg.FilledQuantity,
		arg.FilledPrice,
		arg.LimitPrice,
		arg.ReservedBtcAmount,
		arg.ReservedUsdAmount,
		arg.WebhookUrl,
	)
	var i StandingOrder
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Type,
		&i.State,
		&i.Quantity,
		&i.FilledQuantity,
		&i.FilledPrice,
		&i.LimitPrice,
		&i.ReservedUsdAmount,
		&i.ReservedBtcAmount,
		&i.WebhookUrl,
	)
	return i, err
}

const getAccounts = `-- name: GetAccounts :many
SELECT id, username, token, usd_amount, btc_amount
FROM account
`

func (q *Queries) GetAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.QueryContext(ctx, getAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Token,
			&i.UsdAmount,
			&i.BtcAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStandingOrders = `-- name: GetStandingOrders :many
SELECT id, account_id, type, state, quantity, filled_quantity, filled_price, limit_price, reserved_usd_amount, reserved_btc_amount, webhook_url
FROM standing_order
`

func (q *Queries) GetStandingOrders(ctx context.Context) ([]StandingOrder, error) {
	rows, err := q.db.QueryContext(ctx, getStandingOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StandingOrder
	for rows.Next() {
		var i StandingOrder
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Type,
			&i.State,
			&i.Quantity,
			&i.FilledQuantity,
			&i.FilledPrice,
			&i.LimitPrice,
			&i.ReservedUsdAmount,
			&i.ReservedBtcAmount,
			&i.WebhookUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
