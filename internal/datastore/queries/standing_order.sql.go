// Code generated by sqlc. DO NOT EDIT.
// source: standing_order.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const createStandingOrder = `-- name: CreateStandingOrder :one
INSERT INTO standing_order (account_id, type, state, quantity, limit_price, reserved_btc_amount, reserved_usd_amount,
                            webhook_url)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, account_id, type, state, quantity, filled_quantity, filled_price, limit_price, reserved_usd_amount, reserved_btc_amount, webhook_url
`

type CreateStandingOrderParams struct {
	AccountID         int32
	Type              OrderType
	State             OrderState
	Quantity          int64
	LimitPrice        int64
	ReservedBtcAmount int64
	ReservedUsdAmount int64
	WebhookUrl        sql.NullString
}

func (q *Queries) CreateStandingOrder(ctx context.Context, arg CreateStandingOrderParams) (StandingOrder, error) {
	row := q.db.QueryRowContext(ctx, createStandingOrder,
		arg.AccountID,
		arg.Type,
		arg.State,
		arg.Quantity,
		arg.LimitPrice,
		arg.ReservedBtcAmount,
		arg.ReservedUsdAmount,
		arg.WebhookUrl,
	)
	var i StandingOrder
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Type,
		&i.State,
		&i.Quantity,
		&i.FilledQuantity,
		&i.FilledPrice,
		&i.LimitPrice,
		&i.ReservedUsdAmount,
		&i.ReservedBtcAmount,
		&i.WebhookUrl,
	)
	return i, err
}

const deleteStandingOrder = `-- name: DeleteStandingOrder :exec
DELETE
FROM standing_order
WHERE id = $1
`

func (q *Queries) DeleteStandingOrder(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteStandingOrder, id)
	return err
}

const getBestBuyer = `-- name: GetBestBuyer :one
SELECT id, account_id, type, state, quantity, filled_quantity, filled_price, limit_price, reserved_usd_amount, reserved_btc_amount, webhook_url
FROM standing_order
WHERE state = 'live'
  AND type = 'buy'
  AND limit_price >= $1
ORDER BY limit_price DESC LIMIT 1
`

func (q *Queries) GetBestBuyer(ctx context.Context, limitPrice int64) (StandingOrder, error) {
	row := q.db.QueryRowContext(ctx, getBestBuyer, limitPrice)
	var i StandingOrder
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Type,
		&i.State,
		&i.Quantity,
		&i.FilledQuantity,
		&i.FilledPrice,
		&i.LimitPrice,
		&i.ReservedUsdAmount,
		&i.ReservedBtcAmount,
		&i.WebhookUrl,
	)
	return i, err
}

const getBestMarketBuyer = `-- name: GetBestMarketBuyer :one
SELECT id, account_id, type, state, quantity, filled_quantity, filled_price, limit_price, reserved_usd_amount, reserved_btc_amount, webhook_url
FROM standing_order
WHERE state = 'live'
  AND type = 'buy'
ORDER BY limit_price DESC LIMIT 1
`

func (q *Queries) GetBestMarketBuyer(ctx context.Context) (StandingOrder, error) {
	row := q.db.QueryRowContext(ctx, getBestMarketBuyer)
	var i StandingOrder
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Type,
		&i.State,
		&i.Quantity,
		&i.FilledQuantity,
		&i.FilledPrice,
		&i.LimitPrice,
		&i.ReservedUsdAmount,
		&i.ReservedBtcAmount,
		&i.WebhookUrl,
	)
	return i, err
}

const getBestMarketSeller = `-- name: GetBestMarketSeller :one
SELECT id, account_id, type, state, quantity, filled_quantity, filled_price, limit_price, reserved_usd_amount, reserved_btc_amount, webhook_url
FROM standing_order
WHERE state = 'live'
  AND type = 'sell'
ORDER BY limit_price ASC LIMIT 1
`

func (q *Queries) GetBestMarketSeller(ctx context.Context) (StandingOrder, error) {
	row := q.db.QueryRowContext(ctx, getBestMarketSeller)
	var i StandingOrder
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Type,
		&i.State,
		&i.Quantity,
		&i.FilledQuantity,
		&i.FilledPrice,
		&i.LimitPrice,
		&i.ReservedUsdAmount,
		&i.ReservedBtcAmount,
		&i.WebhookUrl,
	)
	return i, err
}

const getBestSeller = `-- name: GetBestSeller :one
SELECT id, account_id, type, state, quantity, filled_quantity, filled_price, limit_price, reserved_usd_amount, reserved_btc_amount, webhook_url
FROM standing_order
WHERE state = 'live'
  AND type = 'sell'
  AND limit_price <= $1
ORDER BY limit_price ASC LIMIT 1
`

func (q *Queries) GetBestSeller(ctx context.Context, limitPrice int64) (StandingOrder, error) {
	row := q.db.QueryRowContext(ctx, getBestSeller, limitPrice)
	var i StandingOrder
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Type,
		&i.State,
		&i.Quantity,
		&i.FilledQuantity,
		&i.FilledPrice,
		&i.LimitPrice,
		&i.ReservedUsdAmount,
		&i.ReservedBtcAmount,
		&i.WebhookUrl,
	)
	return i, err
}

const getReservedAmounts = `-- name: GetReservedAmounts :one
SELECT COALESCE(SUM(reserved_usd_amount), 0)::bigint as usd_amount, COALESCE(SUM(reserved_btc_amount), 0) ::bigint as btc_amount
FROM standing_order
WHERE account_id = $1
  AND state = 'live'
`

type GetReservedAmountsRow struct {
	UsdAmount int64
	BtcAmount int64
}

func (q *Queries) GetReservedAmounts(ctx context.Context, accountID int32) (GetReservedAmountsRow, error) {
	row := q.db.QueryRowContext(ctx, getReservedAmounts, accountID)
	var i GetReservedAmountsRow
	err := row.Scan(&i.UsdAmount, &i.BtcAmount)
	return i, err
}

const getStandingOrder = `-- name: GetStandingOrder :one
SELECT id, account_id, type, state, quantity, filled_quantity, filled_price, limit_price, reserved_usd_amount, reserved_btc_amount, webhook_url
FROM standing_order
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStandingOrder(ctx context.Context, id int32) (StandingOrder, error) {
	row := q.db.QueryRowContext(ctx, getStandingOrder, id)
	var i StandingOrder
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Type,
		&i.State,
		&i.Quantity,
		&i.FilledQuantity,
		&i.FilledPrice,
		&i.LimitPrice,
		&i.ReservedUsdAmount,
		&i.ReservedBtcAmount,
		&i.WebhookUrl,
	)
	return i, err
}

const getStandingOrders = `-- name: GetStandingOrders :many
SELECT id, account_id, type, state, quantity, filled_quantity, filled_price, limit_price, reserved_usd_amount, reserved_btc_amount, webhook_url
FROM standing_order
WHERE id IN ($1::integer[])
`

func (q *Queries) GetStandingOrders(ctx context.Context, orderIds []int32) ([]StandingOrder, error) {
	rows, err := q.db.QueryContext(ctx, getStandingOrders, pq.Array(orderIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StandingOrder
	for rows.Next() {
		var i StandingOrder
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Type,
			&i.State,
			&i.Quantity,
			&i.FilledQuantity,
			&i.FilledPrice,
			&i.LimitPrice,
			&i.ReservedUsdAmount,
			&i.ReservedBtcAmount,
			&i.WebhookUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const satisfyOrder = `-- name: SatisfyOrder :one
UPDATE standing_order
SET quantity            = quantity - $2,
    filled_quantity     = filled_quantity + $2,
    filled_price        = filled_price + $3,
    state               = CASE
                              WHEN quantity - $2 = 0 THEN 'fulfilled'
                              ELSE state
        END,
    reserved_usd_amount = reserved_usd_amount - $4,
    reserved_btc_amount = reserved_btc_amount - $5
WHERE id = $1
  AND quantity - $2 >= 0 RETURNING id, account_id, type, state, quantity, filled_quantity, filled_price, limit_price, reserved_usd_amount, reserved_btc_amount, webhook_url
`

type SatisfyOrderParams struct {
	ID                int32
	Quantity          int64
	FilledPrice       int64
	ReservedUsdAmount int64
	ReservedBtcAmount int64
}

func (q *Queries) SatisfyOrder(ctx context.Context, arg SatisfyOrderParams) (StandingOrder, error) {
	row := q.db.QueryRowContext(ctx, satisfyOrder,
		arg.ID,
		arg.Quantity,
		arg.FilledPrice,
		arg.ReservedUsdAmount,
		arg.ReservedBtcAmount,
	)
	var i StandingOrder
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Type,
		&i.State,
		&i.Quantity,
		&i.FilledQuantity,
		&i.FilledPrice,
		&i.LimitPrice,
		&i.ReservedUsdAmount,
		&i.ReservedBtcAmount,
		&i.WebhookUrl,
	)
	return i, err
}
